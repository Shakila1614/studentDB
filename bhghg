1|#####FCFS Without arrival

def fcfs_scheduling_from_file(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    process = []  

    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):  
            pid, bt = line.split()  
            process.append((pid, int(bt)))  

    n = len(process)  
    wt = [0] * n  
    tat = [0] * n  
    start_time = 0  
    gantt_chart = []  

    for i in range(n):
        pid, bt = process[i]
        wt[i] = start_time  
        tat[i] = wt[i] + bt  
        gantt_chart.append((pid, start_time, start_time + bt))  
        start_time += bt  

    print("\nProcess\tBurst Time\tWaiting Time\tTurnaround Time")
    for i in range(n):
        pid, bt = process[i]
        print(f"{pid}\t{bt}\t\t{wt[i]}\t\t{tat[i]}")

    avg_wt = sum(wt) / n
    avg_tat = sum(tat) / n

    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")

    print("\nGantt Chart:")
    gantt_line = "| " + " | ".join(f"{pid}" for pid, _, _ in gantt_chart) + " |"
    time_line = "0" + "".join(f"{' ' * 4}{end}" for _, _, end in gantt_chart)
    print(gantt_line) 
    print(time_line)

fcfs_scheduling_from_file("input.txt")

2||######FCFS Arrival
def fcfs_with_idle_time(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    process = []  
    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):  
            pid, at, bt = line.split()
            process.append((pid, int(at), int(bt)))

    process.sort(key=lambda x: x[1])

    n = len(process)  
    start_time = 0
    wt = [0] * n
    tat = [0] * n
    ct = [0] * n
    idle_time = 0
    gantt_chart = []

    for i in range(n):
        pid, at, bt = process[i]
        if start_time < at:
            gantt_chart.append(("Idle", start_time, at))
            idle_time += at - start_time
            start_time = at

        wt[i] = start_time - at
        tat[i] = wt[i] + bt
        ct[i] = start_time + bt

        gantt_chart.append((pid, start_time, start_time + bt))
        start_time += bt

    print("\nProcess\tArrival\tBurst\tWaiting\tTurnaround\tCompletion")
    for i in range(n):
        pid, at, bt = process[i]
        print(f"{pid}\t{at}\t{bt}\t{wt[i]}\t{tat[i]}\t\t{ct[i]}")

    avg_wt = sum(wt) / n
    avg_tat = sum(tat) / n

    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")
    print(f"Total CPU Idle Time: {idle_time}")

    print("\nGantt Chart:")
    gantt_line = "| " + " | ".join(f"{pid}" for pid, _, _ in gantt_chart) + " |"
    time_line = str(gantt_chart[0][1]) + "".join(f"{' ' * 4}{end}" for _, _, end in gantt_chart)
    print(gantt_line)
    print(time_line)

fcfs_with_idle_time("arrive.txt")



3||###SJF Non-Preemptive  Without Arrival Time
def sjf_scheduling_from_file(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    process= []
    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):
            pid, bt = line.split()
            process.append((pid, int(bt)))

    process.sort(key=lambda x: x[1])

    n = len(process)
    wt = [0] * n
    tat = [0] * n
    start_time = 0
    gantt_chart = []
    idle_time = 0  

    for i in range(n):
        pid, bt =process[i]
        wt[i] = start_time
        tat[i] = wt[i] + bt
        gantt_chart.append((pid, start_time, start_time + bt))
        start_time += bt

    print("\nProcess\tBurst Time\tWaiting Time\tTurnaround Time")
    for i in range(n):
        pid, bt = process[i]
        print(f"{pid}\t{bt}\t\t{wt[i]}\t\t{tat[i]}")

    avg_wt = sum(wt) / n
    avg_tat = sum(tat) / n

    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")
    print(f"Idle Time: {idle_time} (All processes arrive at time 0)")

    print("\nGantt Chart:")
    gantt_line = "| " + " | ".join(f"{pid}" for pid, _, _ in gantt_chart) + " |"
    time_line = "0" + "".join(f"{' ' * 4}{end}" for _, _, end in gantt_chart)
    print(gantt_line)
    print(time_line)

sjf_scheduling_from_file("input.txt")




4||#####SJF Non-Preemptive  Arrival Time

def sjf_with_arrival_time(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    processes = []
    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):
            pid, at, bt = line.split()
            processes.append((pid, int(at), int(bt)))

    n = len(processes)
    complete = 0
    time = 0
    idle_time = 0
    is_completed = [False] * n
    gantt_chart = []
    wt = [0] * n
    tat = [0] * n
    ct = [0] * n

    while complete < n:
        idx = -1
        min_bt = float('inf')
        for i in range(n):
            pid, at, bt = processes[i]
            if at <= time and not is_completed[i]:
                if bt < min_bt:
                    min_bt = bt
                    idx = i
                elif bt == min_bt and at < processes[idx][1]:  
                    idx = i

        if idx == -1:
            gantt_chart.append(("Idle", time, time + 1))
            idle_time += 1
            time += 1
        else:
            pid, at, bt = processes[idx]
            gantt_chart.append((pid, time, time+bt))
            wt[idx] = time - at
            tat[idx] = wt[idx]+bt
            ct[idx] = time+bt
            time+=bt
            is_completed[idx] = True
            complete += 1

    print("\nProcess\tArrival\tBurst\tWaiting\tTurnaround\tCompletion")
    for i in range(n):
        pid, at, bt = processes[i]
        print(f"{pid}\t{at}\t{bt}\t{wt[i]}\t{tat[i]}\t\t{ct[i]}")

    avg_wt = sum(wt) / n
    avg_tat = sum(tat) / n

    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")
    print(f"Total CPU Idle Time: {idle_time}")

    print("\nGantt Chart:")
    gantt_line = "| " + " | ".join(f"{pid}" for pid, _, _ in gantt_chart) + " |"
    time_line = str(gantt_chart[0][1]) + "".join(f"{' ' * 4}{end}" for _, _, end in gantt_chart)
    print(gantt_line)
    print(time_line)

sjf_with_arrival_time("arrive.txt")
5||#####  SJF Preemptive Without Arrival Time

def preemptive_sjf_no_arrival(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    processes = []
    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):
            pid, bt = line.split()
            processes.append((pid, int(bt)))

    n = len(processes)
    remaining_time = [bt for _, bt in processes]
    complete = 0
    time = 0
    process_sequence = []
    idle_time = 0

    wt = [0] * n
    tat = [0] * n
    ct = [0] * n

    while complete != n:
        shortest = -1
        min_rt = float('inf')

        for i in range(n):
            if remaining_time[i] > 0 and remaining_time[i] < min_rt:
                min_rt = remaining_time[i]
                shortest = i

        if shortest == -1:
            # CPU is idle
            process_sequence.append("Idle")
            idle_time += 1
            time += 1
            continue

        pid, bt = processes[shortest]
        process_sequence.append(pid)
        remaining_time[shortest] -= 1

        if remaining_time[shortest] == 0:
            complete += 1
            ct[shortest] = time + 1
            tat[shortest] = ct[shortest]
            wt[shortest] = tat[shortest] - bt

        time += 1

    # Output results
    print("\nProcess\tBurst\tWaiting\tTurnaround\tCompletion")
    for i in range(n):
        pid, bt = processes[i]
        print(f"{pid}\t{bt}\t{wt[i]}\t{tat[i]}\t\t{ct[i]}")

    avg_wt = sum(wt) / n
    avg_tat = sum(tat) / n

    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")
    print(f"Total CPU Idle Time: {idle_time}")

    # Gantt chart
    print("\nGantt Chart:")
    chart = "|"
    times = [0]
    for t in range(1, len(process_sequence)):
        if process_sequence[t] != process_sequence[t - 1]:
            chart += f" {process_sequence[t - 1]} |"
            times.append(t)
    chart += f" {process_sequence[-1]} |"
    times.append(len(process_sequence))

    print(chart)
    print("".join(f"{str(t):>5}" for t in times))


# Run with input file
preemptive_sjf_no_arrival("input.txt")



6||##### SJF Preemptive Arrival Time

def preemptive_sjf_with_arrival(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    processes = []  # (PID, ArrivalTime, BurstTime)
    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):
            pid, at, bt = line.split()
            processes.append([pid, int(at), int(bt)])

    n = len(processes)
    remaining_bt = [bt for _, _, bt in processes]
    complete = 0
    time = 0
    is_completed = [False] * n
    start_flag = [False] * n
    start_times = {}
    end_times = {}
    process_sequence = []
    idle_time = 0

    wt = [0] * n
    tat = [0] * n
    ct = [0] * n

    while complete != n:
        idx = -1
        shortest_bt = float('inf')

        for i in range(n):
            pid, at, bt = processes[i]
            if at <= time and remaining_bt[i] > 0:
                if remaining_bt[i] < shortest_bt:
                    shortest_bt = remaining_bt[i]
                    idx = i
                elif remaining_bt[i] == shortest_bt:
                    if at < processes[idx][1]:
                        idx = i

        if idx == -1:
            process_sequence.append("Idle")
            time += 1
            idle_time += 1
            continue

        if not start_flag[idx]:
            start_flag[idx] = True
            start_times[processes[idx][0]] = time

        process_sequence.append(processes[idx][0])
        remaining_bt[idx] -= 1

        if remaining_bt[idx] == 0:
            complete += 1
            ct[idx] = time + 1
            tat[idx] = ct[idx] - processes[idx][1]
            wt[idx] = tat[idx] - processes[idx][2]
            end_times[processes[idx][0]] = time + 1
            is_completed[idx] = True

        time += 1

    print("\nProcess\tArrival\tBurst\tWaiting\tTurnaround\tCompletion")
    for i in range(n):
        pid, at, bt = processes[i]
        print(f"{pid}\t{at}\t{bt}\t{wt[i]}\t{tat[i]}\t\t{ct[i]}")

    avg_wt = sum(wt) / n
    avg_tat = sum(tat) / n
    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")
    print(f"Total Idle Time: {idle_time}")

    # Gantt Chart
    print("\nGantt Chart:")
    chart = "|"
    times = [0]
    for i in range(1, len(process_sequence)):
        if process_sequence[i] != process_sequence[i - 1]:
            chart += f" {process_sequence[i - 1]} |"
            times.append(i)
    chart += f" {process_sequence[-1]} |"
    times.append(len(process_sequence))

    print(chart)
    print("".join(f"{str(t):>5}" for t in times))


# Run it
preemptive_sjf_with_arrival("arrive.txt")


7||##### PRIORITY Non-Preemptive Without Arrival Time
def priority_scheduling_from_file(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    process = []  

    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):  
            pid, bt, pr = line.split()
            process.append((pid, int(bt), int(pr)))

    process.sort(key=lambda x: x[2])

    n = len(process)
    wt = [0] * n
    tat = [0] * n
    start_time = 0
    gantt_chart = []

    for i in range(n):
        pid, bt, pr = process[i]
        wt[i] = start_time
        tat[i] = wt[i] + bt
        gantt_chart.append((pid, start_time, start_time + bt))
        start_time += bt

    print("\nProcess\tBurst Time\tPriority\tWaiting Time\tTurnaround Time")
    for i in range(n):
        pid, bt, pr = process[i]
        print(f"{pid}\t{bt}\t\t{pr}\t\t{wt[i]}\t\t{tat[i]}")

    avg_wt = sum(wt) / n
    avg_tat = sum(tat) / n
    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")

    print("\nGantt Chart:")
    gantt_line = "| " + " | ".join(f"{pid}" for pid, _, _ in gantt_chart) + " |"
    time_line = "0" + "".join(f"{' ' * 4}{end}" for _, _, end in gantt_chart)
    print(gantt_line)
    print(time_line)

priority_scheduling_from_file("input_priority.txt")

8||##### PRIORITY Non-Preemptive Arrival Time
def priority_scheduling_with_arrival(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    process = [] 
    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):
            pid, at, bt, pr = line.split()
            process.append((pid, int(at), int(bt), int(pr)))

    n = len(process)
    complete = 0
    time = 0
    is_completed = [False] * n
    gantt_chart = []
    wt = [0] * n
    tat = [0] * n
    ct = [0] * n
    idle_time = 0

    while complete != n:
        idx = -1
        highest_priority = float('inf')
        for i in range(n):
            pid, at, bt, pr = process[i]
            if at <= time and not is_completed[i]:
                if pr < highest_priority:
                    highest_priority = pr
                    idx = i
                elif pr == highest_priority:
                    if at < processes[idx][1]:
                        idx = i

        if idx == -1:
            gantt_chart.append(("Idle", time, time + 1))
            time += 1
            idle_time += 1
        else:
            pid, at, bt, pr = process[idx]
            wt[idx] = time - at
            tat[idx] = wt[idx]+bt
            ct[idx] = time+bt
            gantt_chart.append((pid, time, time+bt))
            is_completed[idx] = True
            complete += 1
            time +=bt

    print("\nProcess\tArrival\tBurst\tPriority\tWaiting\tTurnaround\tCompletion")
    for i in range(n):
        pid, at, bt, pr = process[i]
        print(f"{pid}\t{at}\t{bt}\t{pr}\t\t{wt[i]}\t{tat[i]}\t\t{ct[i]}")

    avg_wt = sum(wt) / n
    avg_tat = sum(tat) / n
    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")
    print(f"Total Idle Time: {idle_time}")

    print("\nGantt Chart:")
    gantt_line = "| " + " | ".join(f"{pid}" for pid, _, _ in gantt_chart) + " |"
    time_line = str(gantt_chart[0][1]) + "".join(f"{' ' * 4}{end}" for _, _, end in gantt_chart)
    print(gantt_line)
    print(time_line)

priority_scheduling_with_arrival("priority_preemptive.txt")

9||###PRIORITY PREmptive Without arrival
def priority_preemptive_no_arrival(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    process = []
    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):
            pid, bt, pr = line.split()
            process.append([pid, int(bt), int(pr)])

    n = len(process)
    remaining_bt = [bt for _, bt, _ in process]
    complete = 0
    time = 0
    is_completed = [False] * n
    start_flag = [False] * n
    start_times = {}
    end_times = {}
    process_sequence = []

    wt = [0] * n
    tat = [0] * n
    ct = [0] * n

    while complete != n:
        idx = -1
        highest_priority = float('inf')
        for i in range(n):
            pid, bt, pr = process[i]
            if remaining_bt[i] > 0 and pr < highest_priority:
                highest_priority = pr
                idx = i

        if idx == -1:
            process_sequence.append("Idle")
            time += 1
            continue

        if not start_flag[idx]:
            start_flag[idx] = True
            start_times[process[idx][0]] = time

        process_sequence.append(process[idx][0])
        remaining_bt[idx] -= 1

        if remaining_bt[idx] == 0:
            complete += 1
            ct[idx] = time + 1
            tat[idx] = ct[idx]
            wt[idx] = tat[idx] - process[idx][1]
            end_times[process[idx][0]] = time + 1

        time += 1

    print("\nProcess\tBurst\tPriority\tWaiting\tTurnaround\tCompletion")
    for i in range(n):
        pid, bt, pr = process[i]
        print(f"{pid}\t{bt}\t{pr}\t\t{wt[i]}\t{tat[i]}\t\t{ct[i]}")

    avg_wt = sum(wt) / n
    avg_tat = sum(tat) / n
    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")

        # Proper Gantt Chart
    print("\nGantt Chart:")
    chart = "|"
    times = [0]  # Start from time 0

    for i in range(1, len(process_sequence)):
        if process_sequence[i] != process_sequence[i - 1]:
            chart += f" {process_sequence[i - 1]} |"
            times.append(i)
    # Add the last process
    chart += f" {process_sequence[-1]} |"
    times.append(len(process_sequence))

    print(chart)
    print("".join(f"{t:>5}" for t in times))

priority_preemptive_no_arrival("priority_preemptive_no_arrival.txt")
10||##### PRIORITY PREmptive Arrival


def priority_preemptive_with_arrival(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    processes = []  
    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):
            pid, at, bt, pr = line.split()
            processes.append([pid, int(at), int(bt), int(pr)])

    n = len(processes)
    remaining_bt = [bt for _, _, bt, _ in processes]
    complete = 0
    time = 0
    is_completed = [False] * n
    start_flag = [False] * n
    start_times = {}
    end_times = {}
    process_sequence = []
    idle_time = 0

    wt = [0] * n  
    tat = [0] * n
    ct = [0] * n

    while complete != n:
        idx = -1
        highest_priority = float('inf')
        for i in range(n):
            pid, at, bt, pr = processes[i]
            if at <= time and remaining_bt[i] > 0:
                if pr < highest_priority:
                    highest_priority = pr
                    idx = i
                elif pr == highest_priority:
                    if at < processes[idx][1]:
                        idx = i

        if idx == -1:
            process_sequence.append("Idle")
            time += 1
            idle_time += 1
            continue

        if not start_flag[idx]:
            start_flag[idx] = True
            start_times[processes[idx][0]] = time

        process_sequence.append(processes[idx][0])
        remaining_bt[idx] -= 1

        if remaining_bt[idx] == 0:
            complete += 1
            ct[idx] = time + 1
            tat[idx] = ct[idx] - processes[idx][1]
            wt[idx] = tat[idx] - processes[idx][2]
            end_times[processes[idx][0]] = time + 1

        time += 1

    print("\nProcess\tArrival\tBurst\tPriority\tWaiting\tTurnaround\tCompletion")
    for i in range(n):
        pid, at, bt, pr = processes[i]
        print(f"{pid}\t{at}\t{bt}\t{pr}\t\t{wt[i]}\t{tat[i]}\t\t{ct[i]}")

    avg_wt = sum(wt) / n
    avg_tat = sum(tat) / n
    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")
    print(f"Total Idle Time: {idle_time}")

    # Gantt Chart
    print("\nGantt Chart:")
    chart = "|"
    times = [0]
    for i in range(1, len(process_sequence)):
        if process_sequence[i] != process_sequence[i - 1]:
            chart += f" {process_sequence[i - 1]} |"
            times.append(i)
    chart += f" {process_sequence[-1]} |"
    times.append(len(process_sequence))

    print(chart)
    print("".join(f"{str(t):>5}" for t in times))

priority_preemptive_with_arrival("priority_preemptive.txt")

11||#### RR Without Arrival Time
def round_robin_scheduling_from_file(filename, time_quantum):
    # Step 1: Read input file
    with open(filename, 'r') as f:
        lines = f.readlines()

    processes = []  # [PID, BurstTime, RemainingTime]
    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):
            pid, bt = line.split()
            processes.append([pid, int(bt), int(bt)])  # Remaining = BurstTime

    n = len(processes)

    waiting_time = {p[0]: 0 for p in processes}
    turnaround_time = {p[0]: 0 for p in processes}
    complete_time = {}
    ready_queue = processes.copy()
    gantt_chart = []
    time = 0

    # Step 2: Scheduling loop
    while any(p[2] > 0 for p in ready_queue):
        for current in ready_queue:
            pid, bt, rem = current
            if rem > 0:
                exec_time = min(time_quantum, rem)
                gantt_chart.append((pid, time, time + exec_time))
                time += exec_time
                current[2] -= exec_time
                if current[2] == 0:
                    complete_time[pid] = time

    # Step 3: Calculate turnaround and waiting times
    for pid, bt, _ in processes:
        turnaround_time[pid] = complete_time[pid]
        waiting_time[pid] = turnaround_time[pid] - bt

    # Step 4: Print table
    print("\nProcess\tBurst\tWaiting\tTurnaround")
    for pid, bt, _ in processes:
        print(f"{pid}\t{bt}\t{waiting_time[pid]}\t{turnaround_time[pid]}")

    avg_wt = sum(waiting_time.values()) / n
    avg_tat = sum(turnaround_time.values()) / n
    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")

    # Step 5: Gantt chart
    print("\nGantt Chart:")
    chart = "| " + " | ".join(f"{pid}" for pid, _, _ in gantt_chart) + " |"
    timeline = str(gantt_chart[0][1]) + "".join(f"{' ' * 4}{end}" for _, _, end in gantt_chart)
    print(chart)
    print(timeline)


round_robin_scheduling_from_file("input.txt", time_quantum=3)


12||##### RR Arrival Time

def round_robin_with_arrival(filename, time_quantum):
    with open(filename, 'r') as f:
        lines = f.readlines()

    processes = []
    for line in lines:
        line = line.strip()
        if line and not line.startswith("#"):
            pid, at, bt = line.split()
            processes.append([pid, int(at), int(bt), int(bt)])  

    n = len(processes)
    processes.sort(key=lambda x: x[1])  

    time = 0
    ready_queue = []
    gantt_chart = []
    complete = {}
    waiting_time = {}
    turnaround_time = {}
    i = 0  

    while True:
        while i < n and processes[i][1] <= time:
            ready_queue.append(processes[i])
            i += 1

        if ready_queue:
            current = ready_queue.pop(0)
            pid, at, bt, rem = current
            exec_time = min(rem, time_quantum)
            gantt_chart.append((pid, time, time + exec_time))
            time += exec_time
            current[3] -= exec_time

            while i < n and processes[i][1] <= time:
                ready_queue.append(processes[i])
                i += 1

            if current[3] > 0:
                ready_queue.append(current)
            else:
                complete[pid] = time
        else:
            if i < n:
                gantt_chart.append(("Idle", time, processes[i][1]))
                time = processes[i][1]
            else:
                break

    for pid, at, bt, _ in processes:
        tat = complete[pid] - at
        wt = tat - bt
        turnaround_time[pid] = tat
        waiting_time[pid] = wt

    print("\nProcess\tArrival\tBurst\tWaiting\tTurnaround")
    for pid, at, bt, _ in processes:
        print(f"{pid}\t{at}\t{bt}\t{waiting_time[pid]}\t{turnaround_time[pid]}")

    avg_wt = sum(waiting_time.values()) / n
    avg_tat = sum(turnaround_time.values()) / n
    print(f"\nAverage Waiting Time: {avg_wt:.2f}")
    print(f"Average Turnaround Time: {avg_tat:.2f}")

    print("\nGantt Chart:")
    chart = "| " + " | ".join(f"{pid}" for pid, _, _ in gantt_chart) + " |"
    timeline = str(gantt_chart[0][1]) + "".join(f"{' ' * 4}{end}" for _, _, end in gantt_chart)
    print(chart)
    print(timeline)

round_robin_with_arrival("arrive.txt", time_quantum=3)
